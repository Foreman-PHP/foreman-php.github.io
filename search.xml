<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>nginx 设置允许跨域</title>
    <url>/allow-origin/</url>
    <content><![CDATA[<h4 id="在-nginx-配置中添加"><a href="#在-nginx-配置中添加" class="headerlink" title="在 nginx 配置中添加"></a>在 nginx 配置中添加</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name ....</span><br><span class="line">    root ....;</span><br><span class="line">    </span><br><span class="line">    # Cross Domains</span><br><span class="line">    add_header Access-Control-Allow-Origin &quot;*&quot;;</span><br><span class="line">    add_header Access-Control-Allow-Methods &quot;OPTION, POST, GET&quot;;</span><br><span class="line">    add_header Access-Control-Allow-Headers &quot;*&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>相机知识</title>
    <url>/camera/</url>
    <content><![CDATA[<h3 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h3><h4 id="相机的种类"><a href="#相机的种类" class="headerlink" title="相机的种类"></a>相机的种类</h4><ul>
<li>单反</li>
<li>微单</li>
<li>卡片相机</li>
<li>运动相机</li>
<li>手机</li>
</ul>
<h4 id="它们之间的区别"><a href="#它们之间的区别" class="headerlink" title="它们之间的区别"></a>它们之间的区别</h4><h5 id="单反-单镜头反光相机"><a href="#单反-单镜头反光相机" class="headerlink" title="单反(单镜头反光相机)"></a>单反(单镜头反光相机)</h5><p>又大又重, 上手难度大, 携带不便 比较适合职业摄影师. </p>
<p>在取景器中看到的东西就像看镜子里的一样, 但是实际拍摄出来的照片和镜子是不一样的, 所以单反是 所见非所得.</p>
<p><img src="1.png" alt=""></p>
<h5 id="微单-无反相机"><a href="#微单-无反相机" class="headerlink" title="微单(无反相机)"></a>微单(无反相机)</h5><p>微单采用的是电子取景器,在这个取景器中所见即所得 而且没有单反那样庞大的反光组件, 所以微单要比单反小的多,轻的多.</p>
<p><img src="2.png" alt=""></p>
<h5 id="卡片相机"><a href="#卡片相机" class="headerlink" title="卡片相机"></a>卡片相机</h5><p>像卡片一样轻薄的相机,可以放进口袋里. 拍照时镜头会自动伸缩出来. 重量上一般只比手机重一点.</p>
<p>它和单反、微单之间最大区别就是 卡片不能更换镜头. 局限性比较大. </p>
<h5 id="运动相机"><a href="#运动相机" class="headerlink" title="运动相机"></a>运动相机</h5><p>优点: 便携、轻量、防水、防尘 运动记录</p>
<p>缺点: 画质一般</p>
<h5 id="手机"><a href="#手机" class="headerlink" title="手机"></a>手机</h5><p>手机相机最大的优点就是方便,使用简单. 在光线很好的情况下拍出来的照片还是很好的.</p>
<p>缺点:在光线比较复杂的环境,手机就比较无力了</p>
<h3 id="相机硬件知识"><a href="#相机硬件知识" class="headerlink" title="相机硬件知识"></a>相机硬件知识</h3><h4 id="传感器"><a href="#传感器" class="headerlink" title="传感器"></a>传感器</h4><p>传感器的尺寸是相机的最大的硬性指标, 它是对照片影响最大的部件. </p>
<p>通常巨大的广告牌都是由中画幅来拍摄的, 把照片放大可以看都每一个毛孔.</p>
<p><img src="3.png" alt=""></p>
]]></content>
      <categories>
        <category>相机</category>
      </categories>
      <tags>
        <tag>相机</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Composer包在某些情况下拉不来了的问题</title>
    <url>/composer/</url>
    <content><![CDATA[<h3 id="问题说明"><a href="#问题说明" class="headerlink" title="问题说明"></a>问题说明</h3><p>总所周知 国内由于某些神秘力量 在我们访问外网的时候比较慢或者访问不到,包括composer包拉不下来</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li><p>更换阿里云composer镜像 (这个大家都知道)</p>
</li>
<li><p>更换composer包的Github网址 下面是示例(以极光推送包为示例代码)</p>
</li>
</ol>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>打开  package.json 文件 找到其中的 repositories</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .....</span></span><br><span class="line">"repositories": &#123;</span><br><span class="line">    "packagist": &#123;</span><br><span class="line">        "type": "vcs",</span><br><span class="line">        "url": "https://github.com/jpush/jpush-api-php-client"  // 你需要拉下来包的GitHub网址</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且在 package.json 文件的  require 字段中加入</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"jpush/jpush": "*"</span><br></pre></td></tr></table></figure>

<p>之后在命令行运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">composer update</span><br></pre></td></tr></table></figure>

<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>在执行过程中会提示需要一个token 并且附带一个Github网址打开领取你的token复制到命令行回车就OK了</p>
<h4 id="分辨需要设置的代理"><a href="#分辨需要设置的代理" class="headerlink" title="分辨需要设置的代理"></a>分辨需要设置的代理</h4><p>HTTP 形式:<br>git clone <a href="https://github.com/xxx/git.git">https://github.com/xxx/git.git</a></p>
<p>SSH 形式:<br>git clone <a href="mailto:git@github.com">git@github.com</a>:xxx/git.git</p>
<h5 id="HTTP-代理"><a href="#HTTP-代理" class="headerlink" title="HTTP 代理"></a>HTTP 代理</h5><p>git config –global http.proxy <a href="http://127.0.0.1:8080">http://127.0.0.1:8080</a><br>git config –global https.proxy <a href="http://127.0.0.1:8080">http://127.0.0.1:8080</a></p>
<h5 id="socks5-代理（如-Shadowsocks）"><a href="#socks5-代理（如-Shadowsocks）" class="headerlink" title="socks5 代理（如 Shadowsocks）"></a>socks5 代理（如 Shadowsocks）</h5><p>git config –global http.proxy socks5://127.0.0.1:1080<br>git config –global https.proxy socks5://127.0.0.1:1080</p>
<h4 id="取消设置"><a href="#取消设置" class="headerlink" title="取消设置"></a>取消设置</h4><p>git config –global –unset http.proxy<br>git config –global –unset https.proxy</p>
<h5 id="只对-github-进行代理-对国内的仓库不影响-可以这样设置"><a href="#只对-github-进行代理-对国内的仓库不影响-可以这样设置" class="headerlink" title="只对 github 进行代理, 对国内的仓库不影响, 可以这样设置"></a>只对 github 进行代理, 对国内的仓库不影响, 可以这样设置</h5><p>git config –global http.<a href="https://github.com.proxy">https://github.com.proxy</a> <a href="https://127.0.0.1:1080">https://127.0.0.1:1080</a><br>git config –global https.<a href="https://github.com.proxy">https://github.com.proxy</a> <a href="https://127.0.0.1:1080">https://127.0.0.1:1080</a></p>
]]></content>
      <categories>
        <category>composer</category>
      </categories>
      <tags>
        <tag>composer</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>解决TP5跨域问题 cors协议解决</title>
    <url>/cors/</url>
    <content><![CDATA[<h2 id="需求说明"><a href="#需求说明" class="headerlink" title="需求说明"></a>需求说明</h2><p>近期由于项目需要POST跨域请求(get的话用jsonp 我就不写了)</p>
<h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><p>之前一直知道jsonp跨域但是只能get请求 现在要求PSOT 所以用到了cors这个协议</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>cosr 协议 + tp5行为(具体参考TP5官方手册)</p>
<p>你需要在你的BaseController里注册钩子(TP5官方也叫做添加行为标签位)</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">\think\Hook::listen(<span class="string">'response_send'</span>); <span class="comment">// 响应发生标签位 还有其他行为具体参考TP5手册</span></span><br></pre></td></tr></table></figure>

<h3 id="行为定义"><a href="#行为定义" class="headerlink" title="行为定义"></a>行为定义</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> <span class="title">app</span>\<span class="title">api</span>\<span class="title">behavior</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">responseSend</span><span class="params">(&amp;$params)</span></span></span><br><span class="line"><span class="function">    </span>&#123;    <span class="comment">// 响应头设置 我们就是通过设置header来跨域的 这就主要代码了 定义行为只是为了前台每次请求都能走这段代码</span></span><br><span class="line">    	header(<span class="string">'Access-Control-Allow-Origin:*'</span>);     </span><br><span class="line">    	header(<span class="string">'Access-Control-Allow-Methods:*'</span>);  </span><br><span class="line">		header(<span class="string">'Access-Control-Allow-Headers:*'</span>);</span><br><span class="line">		header(<span class="string">'Access-Control-Allow-Credentials:false'</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义完我们就需要去绑定行为 绑定完才会去执行</p>
<p>建议绑定行为写在application下面tags.php文件中统一管理</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">'response_send'</span> =&gt; [</span><br><span class="line">       <span class="string">'app\\api\\behavior\\Test'</span>   </span><br><span class="line">   ],</span><br></pre></td></tr></table></figure>

<p>参考链接:</p>
<p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">http://www.ruanyifeng.com/blog/2016/04/cors.html</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/24411090">https://zhuanlan.zhihu.com/p/24411090</a></p>
]]></content>
      <categories>
        <category>TP框架</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>thinkphp</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/design-patterns/</url>
    <content><![CDATA[<h3 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h3><ul>
<li>是前辈对代码开发经验的总结, 是解决特定问题的一系列的套路, </li>
<li>使用设计模式是为了可重用代码, 让代码更容易被他人理解,保证代码可靠性,程序的重用性.</li>
</ul>
<h3 id="GoF23"><a href="#GoF23" class="headerlink" title="GoF23"></a>GoF23</h3><blockquote>
<p>创建型模式 (用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。)</p>
</blockquote>
<ul>
<li>单例模式, 工厂模式, 抽象工厂模式, 建造者模式, 原型模式</li>
</ul>
<blockquote>
<p>结构型模式 (用于描述如何将类或对象按某种布局组成更大的结构)</p>
</blockquote>
<ul>
<li>适配器模式, 桥接模式, 装饰模式, 组合模式, 外观模式, 亨元模式, 代理模式</li>
</ul>
<blockquote>
<p>行为型模式 (用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责)</p>
</blockquote>
<ul>
<li>模板方法模式, 策略模式, 命令模式, 职责链模式, 状态模式, 观察者模式, 中介者模式, 迭代器模式, 访问者模式, 备忘录模式, 解释器模式</li>
</ul>
<h3 id="OOP七大原则"><a href="#OOP七大原则" class="headerlink" title="OOP七大原则"></a>OOP七大原则</h3><ul>
<li>开闭原则: 对扩展开放, 对修改关闭. 意思是对新增的代码或功能不去 影响或修改之前的代码, 可以独立扩展.</li>
<li>里氏替换原则: 继承必须确保类所拥有的性质在子类中任然要成立. 意思是继承必须保证父类在子类中的功能, 不要去修改父类的功能方法</li>
<li>依赖倒置原则: 要面向接口编程, 不要面向实现编程.  意思是 高层的模块不应该依赖于低层的模块, 他们要依赖于抽象层.</li>
<li>单一职责原则: 控制类的大小, 将对象解耦, 提高内聚性. 意思是类中的一个方法尽力只做一件事情.</li>
<li>接口隔离原则: 要为各个类建立它们的专用接口.</li>
<li>迪米特法则:   只于你的朋友交谈, 不跟陌生人交谈. </li>
<li>合成复用原则: 尽量先使用组合或者聚合的关联关系来实现, 其次再考虑实现继承关系来实现.</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Compose</title>
    <url>/docker-compose/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>之前使用Docker 都是手动去操作单个容器 比如: 编写DockerFile 手动执行 build run 等操作, 这样的弊端是如果我们有很多服务的话一个一个的执行会很麻烦<br>所以使用Docker Compose来轻松高效的管理容器, 可以定义运行多个容器.</p>
<blockquote>
<p>Docker Compose 特性</p>
</blockquote>
<ul>
<li>定义, 运行多个容器.</li>
<li>YAML file 配置文件.</li>
<li>docker-compose 命令.</li>
</ul>
<blockquote>
<p>自己理解<br>compose是docker官方开源的项目, 需要安装.<br>比如有一个 web服务 我们需要安装 nginx, php, mysql, redis 多个容器,我们使用DockerFile一个一个的去写, 一个一个的去运行命令会非常的麻烦.</p>
</blockquote>
<h3 id="安装-docker-compose"><a href="#安装-docker-compose" class="headerlink" title="安装 docker-compose"></a>安装 docker-compose</h3><ul>
<li>官方提供的GitHub地址太慢,这里使用国内的镜像: <a href="https://get.daocloud.io/">地址</a></li>
<li>安装完成使用命令 docker-compose version 有版本信息表示安装成功</li>
</ul>
<h3 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h3><ul>
<li>参考官方<a href="https://docs.docker.com/compose/gettingstarted/#prerequisites">示例</a></li>
</ul>
<ol>
<li>创建应用 app.py</li>
<li>Dockerfile 应用打包成镜像</li>
<li>docker-compose yaml文件 定义整个服务(所需的环境)</li>
<li>启动compose项目 </li>
</ol>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ol>
<li>创建网络</li>
<li>执行 docker-composer yaml</li>
<li>启动服务</li>
</ol>
<h3 id="docker-compose-配置编写规则"><a href="#docker-compose-配置编写规则" class="headerlink" title="docker-compose 配置编写规则"></a>docker-compose 配置编写规则</h3><h4 id="yaml-规则"><a href="#yaml-规则" class="headerlink" title="yaml 规则"></a>yaml 规则</h4><ul>
<li>参考官方<a href="https://docs.docker.com/compose/compose-file/">文档</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#  yaml 有三层</span><br><span class="line"></span><br><span class="line">version &#39;&#39; # 1.版本 对应docker版本</span><br><span class="line">service &#39;&#39; # 2.服务</span><br><span class="line">    服务1 : web</span><br><span class="line">        # 服务配置</span><br><span class="line">        image</span><br><span class="line">        build</span><br><span class="line">        network</span><br><span class="line">    服务2 : redis</span><br><span class="line">    .....</span><br><span class="line"></span><br><span class="line"># 3.其他配置 网络&#x2F;卷&#x2F;全局规则</span><br><span class="line">volumes:</span><br><span class="line">networks:</span><br><span class="line">configs:</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 命令</title>
    <url>/docker-study-command/</url>
    <content><![CDATA[<h3 id="Docker-常用命令"><a href="#Docker-常用命令" class="headerlink" title="Docker 常用命令"></a>Docker 常用命令</h3><h4 id="Docker-帮助命令"><a href="#Docker-帮助命令" class="headerlink" title="Docker 帮助命令"></a>Docker 帮助命令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker version # 显示docker的版本信息</span><br><span class="line">docker info    # 显示docker的系统信息</span><br><span class="line">docker 命令 --help  # 帮助命令</span><br></pre></td></tr></table></figure>

<h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><h4 id="docker-images-查看主机上所有的镜像"><a href="#docker-images-查看主机上所有的镜像" class="headerlink" title="docker images 查看主机上所有的镜像"></a>docker images 查看主机上所有的镜像</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker@docker-VirtualBox:~$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              bf756fb1ae65        8 months ago        13.3kB</span><br></pre></td></tr></table></figure>
<ol>
<li>解释</li>
</ol>
<ul>
<li>REPOSITORY 镜像的仓库源</li>
<li>TAG        镜像的标签</li>
<li>IMAGE ID   镜像的ID</li>
<li>CREATED    镜像的创建时间</li>
<li>SIZE       镜像的大小</li>
</ul>
<ol start="2">
<li>可选项<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-a  --all   # 列出所有镜像</span><br><span class="line">-q  --quiet # 只显示镜像的ID</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="docker-search-搜索镜像"><a href="#docker-search-搜索镜像" class="headerlink" title="docker search 搜索镜像"></a>docker search 搜索镜像</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker search mysql</span><br><span class="line">NAME                              DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">mysql                             MySQL is a widely used, open-source relation…   9945                [OK]</span><br><span class="line">mariadb                           MariaDB is a community-developed fork of MyS…   3638                [OK]</span><br><span class="line">mysql&#x2F;mysql-server                Optimized MySQL Server Docker images. Create…   725                                     [OK]</span><br><span class="line">percona                           Percona Server is a fork of the MySQL relati…   508                 [OK]</span><br></pre></td></tr></table></figure>
<ol>
<li>可选项 -f, 过滤<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker search mysql -f STARS&#x3D;3000</span><br><span class="line">NAME                DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">mysql               MySQL is a widely used, open-source relation…   9945                [OK]</span><br><span class="line">mariadb             MariaDB is a community-developed fork of MyS…   3638                [OK]</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="docker-pull-拉去镜像"><a href="#docker-pull-拉去镜像" class="headerlink" title="docker pull 拉去镜像"></a>docker pull 拉去镜像</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 下载镜像 docker pull 镜像名称[:tag]</span><br><span class="line">docker@docker-VirtualBox:~$ docker pull mysql</span><br><span class="line">Using default tag: latest  # 如果不写 tag 默认就是 latest</span><br><span class="line">latest: Pulling from library&#x2F;mysql </span><br><span class="line">bf5952930446: Pull complete # 分层下载 docker image的核心 联合文件系统</span><br><span class="line">8254623a9871: Pull complete</span><br><span class="line">938e3e06dac4: Pull complete</span><br><span class="line">ea28ebf28884: Pull complete</span><br><span class="line">f3cef38785c2: Pull complete</span><br><span class="line">894f9792565a: Pull complete</span><br><span class="line">1d8a57523420: Pull complete</span><br><span class="line">6c676912929f: Pull complete</span><br><span class="line">3cdd8ff735c9: Pull complete</span><br><span class="line">4c70cbe51682: Pull complete</span><br><span class="line">e21cf0cb4dc3: Pull complete</span><br><span class="line">28c36cd3abcc: Pull complete</span><br><span class="line">Digest: sha256:6ded54eb1e5d048d8310321ba7b92587e9eadc83b519165b70bbe47e4046e76a # 签名</span><br><span class="line">Status: Downloaded newer image for mysql:latest</span><br><span class="line">docker.io&#x2F;library&#x2F;mysql:latest # 真实地址</span><br><span class="line"></span><br><span class="line"># docker pull mysql 等于 docker pull  docker.io&#x2F;library&#x2F;mysql:latest</span><br></pre></td></tr></table></figure>

<h4 id="docker-rmi-删除镜像"><a href="#docker-rmi-删除镜像" class="headerlink" title="docker rmi 删除镜像"></a>docker rmi 删除镜像</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rmi 镜像名称 # 删除单个镜像</span><br><span class="line">docker rmi 镜像id # 删除单个镜像</span><br><span class="line">docker rmi 镜像id 镜像id 镜像id # 删除多个镜像</span><br><span class="line">docker rmi -f $(docker images -ag) # 删除全部镜像</span><br></pre></td></tr></table></figure>


<h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h3><h4 id="docker-run-新建容器并启动"><a href="#docker-run-新建容器并启动" class="headerlink" title="docker run 新建容器并启动"></a>docker run 新建容器并启动</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run [可选参数] image</span><br><span class="line"></span><br><span class="line"># 参数说明</span><br><span class="line">--name&#x3D;&quot;name&quot; 容器名字</span><br><span class="line">-d            后台方式运行</span><br><span class="line">-it           使用交互方式运行, 进入容器内</span><br><span class="line">-p            指定容器端口 -p 8080:8080</span><br><span class="line">   -p ip:主机端口:容器端口</span><br><span class="line">   -p 主机端口:容器端口 (常用)</span><br><span class="line">   -P 容器端口 </span><br><span class="line">-P 随机指定端口</span><br></pre></td></tr></table></figure>

<h4 id="docker-ps-查看容器"><a href="#docker-ps-查看容器" class="headerlink" title="docker ps 查看容器"></a>docker ps 查看容器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># docker ps 命令</span><br><span class="line">     # 列出正在运行的容器</span><br><span class="line">-a   # 列出所有容器</span><br><span class="line">-n&#x3D;? # 列出最近创建的容器</span><br><span class="line">-q   # 只显示容器编号</span><br></pre></td></tr></table></figure>

<h4 id="docker-rm-删除容器"><a href="#docker-rm-删除容器" class="headerlink" title="docker rm 删除容器"></a>docker rm 删除容器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rm 容器id  # 删除指定容器, 先停止容器才能删除, 强制删除 rm -f</span><br><span class="line">docker rm $(docker ps -aq) # 删除所有容器</span><br></pre></td></tr></table></figure>

<h4 id="启动和停止容器"><a href="#启动和停止容器" class="headerlink" title="启动和停止容器"></a>启动和停止容器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker start 容器id   # 启动容器</span><br><span class="line">docker restart 容器id # 重启容器</span><br><span class="line">docker stop 容器id    # 停止当前正在运行的容器</span><br><span class="line">docker kill 容器id    # 强制停止当前容器</span><br></pre></td></tr></table></figure>

<h3 id="Docker-其他常用命令"><a href="#Docker-其他常用命令" class="headerlink" title="Docker 其他常用命令"></a>Docker 其他常用命令</h3><h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker logs 容器id</span><br><span class="line"> - tf 显示日志</span><br><span class="line"> -- tail number 显示条数</span><br></pre></td></tr></table></figure>

<h4 id="查看容器内部的进程信息"><a href="#查看容器内部的进程信息" class="headerlink" title="查看容器内部的进程信息"></a>查看容器内部的进程信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker top 容器id</span><br></pre></td></tr></table></figure>

<h4 id="查看镜像的元数据"><a href="#查看镜像的元数据" class="headerlink" title="查看镜像的元数据"></a>查看镜像的元数据</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker inspect 容器id</span><br></pre></td></tr></table></figure>

<h4 id="从容器内拷贝文件到主机上"><a href="#从容器内拷贝文件到主机上" class="headerlink" title="从容器内拷贝文件到主机上"></a>从容器内拷贝文件到主机上</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker cp 容器id:容器内路径 主机路径</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 容器数据卷</title>
    <url>/docker-study-data/</url>
    <content><![CDATA[<h3 id="什么是容器数据卷"><a href="#什么是容器数据卷" class="headerlink" title="什么是容器数据卷"></a>什么是容器数据卷</h3><ul>
<li>docker的理念, 将应用和环境打包成一个镜像, 如果应用产生数据, 那么我们删除容器数据就会丢失.</li>
<li>所以我们需要数据可以持久化, 比如 mysql的数据可以存储在本地! 并且容器之间可以数据共享, 这就是数据卷技术.</li>
</ul>
<h3 id="使用数据卷挂载目录"><a href="#使用数据卷挂载目录" class="headerlink" title="使用数据卷挂载目录"></a>使用数据卷挂载目录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 命令中 -v 就是在挂载目录 主机目录:容器内目录</span><br><span class="line">docker run -it -v &#x2F;home&#x2F;test:&#x2F;home centos &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以使用 docker inspect 命令 查看挂载</p>
</blockquote>
<p><img src="WX20200911-112210.png" alt=""></p>
<h3 id="mysql容器实战"><a href="#mysql容器实战" class="headerlink" title="mysql容器实战"></a>mysql容器实战</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 命令详解</span><br><span class="line"># -d 后台运行</span><br><span class="line"># -p 端口映射 宿主机端口:容器内端口</span><br><span class="line"># -v 数据卷挂载</span><br><span class="line"># -e 环境配置</span><br><span class="line"># --name 容器名字</span><br><span class="line"></span><br><span class="line">docker run -d -p 3333:3306 -v &#x2F;home&#x2F;docker&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql&#x2F;conf.d -v &#x2F;home&#x2F;docker&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql -e MYSQL_ROOT_PASSWORD&#x3D;root --name my-mysql mysql</span><br></pre></td></tr></table></figure>
<blockquote>
<p>假设我们将容器删除, 就会发现挂载到本地的数据劵依旧没有丢失, 这就实现了容器数据化持久功能</p>
</blockquote>
<h3 id="具名挂载和匿名挂载"><a href="#具名挂载和匿名挂载" class="headerlink" title="具名挂载和匿名挂载"></a>具名挂载和匿名挂载</h3><blockquote>
<p>docker的挂载方式有三种 具名挂载和匿名挂载 指定路径挂载, 上面mysql实战中就使用了指定路径挂载</p>
</blockquote>
<h4 id="匿名挂载"><a href="#匿名挂载" class="headerlink" title="匿名挂载"></a>匿名挂载</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -v 直接写容器内路径</span><br><span class="line"></span><br><span class="line">docker run -d -P --name nginx01 -v &#x2F;etc&#x2F;nginx nginx</span><br><span class="line"></span><br><span class="line"># 启动容器后, 可以使用 docker volume ls 命令来查看所有卷</span><br><span class="line">docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               44bf15e29c95e85ab32f4d94c7e2766d0880d602342cf1ac00e3044c1c3415f8</span><br><span class="line">local               723cc8cf114d9d4bb4ca51092b11fccf2b29d0927739414938a2cde22de4e43e</span><br></pre></td></tr></table></figure>

<h4 id="具名挂载"><a href="#具名挂载" class="headerlink" title="具名挂载"></a>具名挂载</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -v 卷名:容器内路径</span><br><span class="line">docker run -d -P --name nginx02 -v juming:&#x2F;etc&#x2F;nginx nginx</span><br><span class="line"></span><br><span class="line"># 再次查看所有的卷</span><br><span class="line">docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               44bf15e29c95e85ab32f4d94c7e2766d0880d602342cf1ac00e3044c1c3415f8</span><br><span class="line">local               723cc8cf114d9d4bb4ca51092b11fccf2b29d0927739414938a2cde22de4e43e</span><br><span class="line">local               juming</span><br></pre></td></tr></table></figure>

<h4 id="查看匿名和具名挂载的目录"><a href="#查看匿名和具名挂载的目录" class="headerlink" title="查看匿名和具名挂载的目录"></a>查看匿名和具名挂载的目录</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用 docker volume inspect 卷名来查看挂载的目录</span><br><span class="line"></span><br><span class="line">docker volume  inspect 44bf15e29c95e85ab32f4d94c7e2766d0880d602342cf1ac00e3044c1c3415f8</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2020-09-11T05:49:44Z&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: null,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;44bf15e29c95e85ab32f4d94c7e2766d0880d602342cf1ac00e3044c1c3415f8&#x2F;_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;44bf15e29c95e85ab32f4d94c7e2766d0880d602342cf1ac00e3044c1c3415f8&quot;,</span><br><span class="line">        &quot;Options&quot;: null,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>/var/lib/docker/</code> 目录就是docker的工作目录</li>
<li>在其中 <code>/var/lib/docker/volumes/</code> 目录就是存放了 docker 的所有挂载卷</li>
<li>进入到目录中就可以看到挂载的目录了<br><img src="WX20200911-140715.png" alt=""></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-v 容器内路径            # 匿名挂载</span><br><span class="line">-v 卷名:容器内路径        # 具名挂载</span><br><span class="line">-v 宿主机路径:容器内路径   # 指定路径挂载</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>DockerFile</title>
    <url>/docker-study-docker-file/</url>
    <content><![CDATA[<h3 id="DockerFile-介绍"><a href="#DockerFile-介绍" class="headerlink" title="DockerFile 介绍"></a>DockerFile 介绍</h3><ul>
<li>dockerfile 是用来构建docker镜像的文件, 命令参数脚本.</li>
</ul>
<h3 id="DockerFile-构建过程"><a href="#DockerFile-构建过程" class="headerlink" title="DockerFile 构建过程"></a>DockerFile 构建过程</h3><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><ul>
<li>每个保留关键字(指令) 都必须是大写字母</li>
<li>从上到下的执行顺序</li>
<li>每一个指令都会创建提交一个新的镜像层, 并提交</li>
</ul>
<h3 id="DockerFile-指令"><a href="#DockerFile-指令" class="headerlink" title="DockerFile 指令"></a>DockerFile 指令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM        # 基础镜像, 所有的东西都从这里开始</span><br><span class="line">MAINTAINER  # 镜像作者 姓名+邮箱</span><br><span class="line">RUN         # 镜像构建的时候需要运行的命令 </span><br><span class="line">ADD         # 需要加入的内容 比如 mysql, nginx, Ubuntu 等</span><br><span class="line">WORKDIR     # 镜像的工作目录</span><br><span class="line">VOLUME      # 挂载目录</span><br><span class="line">EXPOSE      # 暴露端口配置</span><br><span class="line">CMD         # 指定这个容器启动的时候要运行的命令, 只有最后一个会生效, 可被替代</span><br><span class="line">ENTRYPOINT  # 指定这个容器启动的时候要运行的命令, 可以追加命令</span><br><span class="line">ONBUILD     # 当构建一个被继承 DockerFile 这个时候需要这个命令</span><br><span class="line">COPY        # 将我们的文件拷贝到镜像中</span><br><span class="line">ENV         # 构建的时候设置环境变量</span><br></pre></td></tr></table></figure>

<h3 id="使用-DockerFile-构建-dnmp"><a href="#使用-DockerFile-构建-dnmp" class="headerlink" title="使用 DockerFile 构建 dnmp"></a>使用 DockerFile 构建 dnmp</h3><p>todo …. </p>
<h3 id="发布镜像到-DockerHub"><a href="#发布镜像到-DockerHub" class="headerlink" title="发布镜像到 DockerHub"></a>发布镜像到 DockerHub</h3><h4 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h4><ol>
<li>注册docker账号</li>
<li>在终端登录上自己的账号 命令: docker login</li>
</ol>
<h4 id="发布命令"><a href="#发布命令" class="headerlink" title="发布命令"></a>发布命令</h4><blockquote>
<p>docker push 作者名字/镜像名字:标签名字</p>
</blockquote>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 镜像详解</title>
    <url>/docker-study-image/</url>
    <content><![CDATA[<h4 id="镜像是什么"><a href="#镜像是什么" class="headerlink" title="镜像是什么"></a>镜像是什么</h4><p>镜像是一种轻量级, 可执行的独立的软件包, 用来打包软件运行环境和基于运行环境开发的软件, 它包含运行某个软件所需要的内容 比如: 代码, 环境, 库, 配置文件等, 所有的应用, 直接打包docker镜像 就可以直接跑起来.</p>
<h4 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a>Docker镜像加载原理</h4><blockquote>
<p>UnionFS(联合文件系统)</p>
</blockquote>
<p>UnionFS(联合文件系统) 是一种分层,轻量级并且高性能的文件系统, 它支持对文件系统的修改作为一次提交来一层层的叠加, 同时可以将不同目录挂载到同一个虚拟文件系统下. UnionFS文件系统是 Docker 镜像的基础. 镜像可以通过分层来进行继承, 基于基础镜像(没有父镜像, 可以制作各种具体的应用镜像).</p>
<p>特性: 一次同时加载多个文件系统, 但从外面看起来, 只能看到一个文件系统, 联合加载会把各层文件系统叠加起来, 这样最终的文件系统会包含所有底层的文件和目录</p>
<blockquote>
<p>Docker镜像加载原理</p>
</blockquote>
<ul>
<li><p>docker的镜像实际上由一层一层的文件系统组成, 这种层级的文件系统UnionFS.</p>
</li>
<li><p>bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统, 在Docker镜像的最底层是bootfs. 这一层与我们典型的Linux/Unix系统是一样的, 包含boot加载器和内核. 当boot加载完成之后整个内核就都在内存中了, 此时内存的使用权已由bootfs转交给内核, 此时系统也会卸载bootfs. </p>
</li>
<li><p>rootfs(root file system), 在bootfs之上. 包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件. rootfs就是各种不同的操作系统发行版, 比如Ubuntu, Centos等等.</p>
</li>
</ul>
<blockquote>
<p>理解</p>
</blockquote>
<ul>
<li>一个linux系统按启动顺序可以划分为: 引导加载, 内核, 文件系统, 应用程序.</li>
<li>系统启动都需要引导加载也就是 bootloader和kernel, 系统运行起来之后就不需要bootfs, 也就会把它卸载掉 </li>
<li>对于Docker安装OS来说Docker使用了Linux本身的bootfs, 只需要安装自己所需的rootfs  </li>
</ul>
<p><img src="WX20200910-134218.png" alt=""></p>
<h4 id="分层理解"><a href="#分层理解" class="headerlink" title="分层理解"></a>分层理解</h4><ul>
<li>Docker安装普通镜像来说 Docker本身是分层下载镜像, 所以可以提取出公共层镜像进行复用.</li>
</ul>
<p><img src="WX20200910-145017.png" alt=""></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 安装</title>
    <url>/docker-study-install/</url>
    <content><![CDATA[<h4 id="Docker的基本组成"><a href="#Docker的基本组成" class="headerlink" title="Docker的基本组成"></a>Docker的基本组成</h4><p><img src="WX20200909-103930.png" alt=""></p>
<ul>
<li>镜像(Image): docker镜像, 就相当于是镜像模板, 比如官方镜像Ubuntu:16.04就包含了完整的一套Ubuntu16.4最小系统 可以通过镜像来创建一个或多个容器.</li>
<li>容器(Container): 镜像和容器的关系, 就像面向对象程序设计种的类和对象一样, 镜像是静态的定义, 容器时镜像运行时的实体, 容器可以被创建 启动 停止 删除 暂停等.</li>
<li>仓库(Repository): 仓库可看成一个代码控制中心, 用来保存镜像. 仓库分为公有仓库和私有仓库. 其中<a href="https://hub.docker.com/">DockerHub</a>就是docker官方的仓库地址</li>
</ul>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p><a href="https://docs.docker.com/engine/install/">docker官方文档</a> 我的系统是 ubuntu 所以接下来的教程都是在 ubuntu 中安装的</p>
<ol>
<li><p>卸载旧的版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure></li>
<li><p>更新apt软件源并允许apt通过HTTPS使用仓库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加Docker的官方GPG密钥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -fsSL https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu&#x2F;gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="4">
<li>设置Docker稳定版软件源<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 官方源, 国内安装比较慢推荐使用阿里云的</span><br><span class="line">sudo add-apt-repository \</span><br><span class="line">   &quot;deb [arch&#x3D;amd64] https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu \</span><br><span class="line">   $(lsb_release -cs) \</span><br><span class="line">   stable&quot;</span><br><span class="line"></span><br><span class="line"># 阿里云软件源</span><br><span class="line">sudo add-apt-repository &quot;deb [arch&#x3D;amd64] https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu $(lsb_release -cs) stable&quot;</span><br></pre></td></tr></table></figure></li>
<li>添加仓库后, 更新apt源索引 并且安装最新的 docker-ce 社区版</li>
</ol>
<ul>
<li>安装时最好设置一下阿里云的镜像会快很多 <a href="https://developer.aliyun.com/mirror/">阿里云镜像源</a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="6">
<li><p>启动docker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service docker start</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 docker version 判断是否安装成功<br><img src="./WX20200909-114550.png" alt=""></p>
</li>
</ol>
<h3 id="运行-hello-world"><a href="#运行-hello-world" class="headerlink" title="运行 hello-world"></a>运行 hello-world</h3><h4 id="使用-docker-run-hello-world"><a href="#使用-docker-run-hello-world" class="headerlink" title="使用 docker run hello-world"></a>使用 docker run hello-world</h4><p><img src="WX20200909-115716.png" alt=""></p>
<ul>
<li>上图可以看到第一步运行 docker run hello-world 命令后先在本来没有在本地找到 hello-world 镜像 </li>
<li>第二步开始去远程仓库拉去 hello-world 镜像, 拉去完成之后返回一串签名信息</li>
<li>第三步输出了 Hello from Docker! 表示已经完成了</li>
</ul>
<h4 id="docker-run-命令详细分析"><a href="#docker-run-命令详细分析" class="headerlink" title="docker run 命令详细分析"></a>docker run 命令详细分析</h4><p><img src="WX20200909-133458.png" alt=""></p>
<h4 id="查看下载的镜像"><a href="#查看下载的镜像" class="headerlink" title="查看下载的镜像"></a>查看下载的镜像</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<p><img src="WX20200909-120332.png" alt=""></p>
<h4 id="卸载-docker"><a href="#卸载-docker" class="headerlink" title="卸载 docker"></a>卸载 docker</h4><ol>
<li>卸载Docker Engine, CLI和Containerd软件包<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get purge docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure></li>
<li>手动删除docker的资源 比如: images, containers, volumes<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rm -rf &#x2F;var&#x2F;lib&#x2F;docker</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="Docker底层原理"><a href="#Docker底层原理" class="headerlink" title="Docker底层原理"></a>Docker底层原理</h4><blockquote>
<p>Docker是怎么工作的?</p>
</blockquote>
<ul>
<li>Docker是一个 Client -  Server 结构的系统, Docker的守护进程运行在主机上, 通过 Socket从客户端访问</li>
<li>DockerServer 接收到 DockerClient的指令, 就会执行这个命令</li>
</ul>
<p><img src="WX20200909-143306.png" alt=""></p>
<blockquote>
<p>Docker为什么比虚拟机快</p>
</blockquote>
<p><img src="WX20200909-143747.png" alt=""></p>
<ol>
<li>Docker有着比虚拟机更少的抽象层</li>
<li>Docker利用的是宿主机的内核, 而 vm 需要 Guest OS.</li>
<li>所以说新建一个容器的时候 docker需要像虚拟机一个重新加载一个操作系统内核避免引导, 虚拟机加载GuestOS是分钟级的. 而docker是里面宿主机的操作系统, 省略了复杂的过程是秒级的.</li>
</ol>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 制作自己的镜像</title>
    <url>/docker-study-make/</url>
    <content><![CDATA[<h4 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h4><blockquote>
<p>commit 命令</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker commit -m &quot;描述信息&quot;  -a&#x3D;&quot;作者&quot; 容器id 目标镜像明:[tag]</span><br></pre></td></tr></table></figure>

<h4 id="发布镜像"><a href="#发布镜像" class="headerlink" title="发布镜像"></a>发布镜像</h4><a href="/docker-study-docker-file/" title="DockerFile">DockerFile</a>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 网络原理</title>
    <url>/docker-study-network/</url>
    <content><![CDATA[<h3 id="理解Docker0网卡"><a href="#理解Docker0网卡" class="headerlink" title="理解Docker0网卡"></a>理解Docker0网卡</h3><p><img src="WX20200922-105325.png" alt=""></p>
<blockquote>
<p>问题: docker 是如何处理容器网络访问的?</p>
</blockquote>
<ul>
<li>我们通过命令查看某一个容器的内部ip 可以看出容器内部的ip和docker0网卡是在同一网段的</li>
<li>并且宿主机和容器之间是可以相互ping通的<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it tomcat1 ip addr</span><br></pre></td></tr></table></figure>
<img src="WX20200922-110556.png" alt=""></li>
</ul>
<blockquote>
<p>原理</p>
</blockquote>
<ul>
<li>每启动一个容器, docker就会给容器分配一个ip. 只要安装了docker 就会有一个docker0的网卡</li>
<li>docker0的网卡和真实的物理网卡之间是桥接模式</li>
<li>使用的技术是 evth-pair技术</li>
</ul>
<h3 id="evth-pair-技术"><a href="#evth-pair-技术" class="headerlink" title="evth-pair 技术"></a>evth-pair 技术</h3><ul>
<li>当我们启动容器的时候就会生成一对网卡 </li>
<li>evth-pair 就是一对虚拟设备接口, 他们都是成对出现的 一段连着协议, 一段彼此相连</li>
<li>有了这种特性 evth-pair 充当一个桥梁,连接各种虚拟设备</li>
</ul>
<p><img src="WX20200922-111529.png" alt=""><br><img src="WX20200922-111619.png" alt=""></p>
<h4 id="画图理解"><a href="#画图理解" class="headerlink" title="画图理解"></a>画图理解</h4><p><img src="WX20200922-111821.png" alt=""></p>
<blockquote>
<p>结论</p>
</blockquote>
<ul>
<li>tomcat01 和 tomcat02 是公用一个路由器 docker0</li>
<li>容器在不指定网络的情况下, 都是走docker0 路由的 docker会给容器分配一个默认的ip</li>
<li>Docker中所有的网络接口都是虚拟的</li>
</ul>
<p><img src="WX20200922-112200.png" alt=""></p>
<h3 id="容器互联-–link"><a href="#容器互联-–link" class="headerlink" title="容器互联 –link"></a>容器互联 –link</h3><ul>
<li>通过上面我们会发现容器之间可以通过ip地址是可以ping通的</li>
<li>那么再某些情况下不用ip 我们可不可以用容器名的方式 ping通?</li>
<li>可以使用 –link 来解决上面的问题</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 我们重新启动一个tomcat 并且 --link tomcat1</span><br><span class="line">docker run -d -P --link tomcat tomcat</span><br><span class="line"></span><br><span class="line"># 完成之后我们就可以ping通了</span><br><span class="line">docker exec -it jovial_chebyshev ping tomcat1</span><br><span class="line"></span><br><span class="line">PING tomcat1 (172.17.0.4) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcat1 (172.17.0.4): icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.069 ms</span><br><span class="line">64 bytes from tomcat1 (172.17.0.4): icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.060 ms</span><br><span class="line">64 bytes from tomcat1 (172.17.0.4): icmp_seq&#x3D;4 ttl&#x3D;64 time&#x3D;0.069 ms</span><br><span class="line">--- tomcat1 ping statistics ---</span><br></pre></td></tr></table></figure>

<ul>
<li>这样做有一个弊端就是 反向 ping 是不通的</li>
<li>原理就是在 jovial_chebyshev 容器中的 /etc/host 中有写 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it jovial_chebyshev cat &#x2F;etc&#x2F;hosts</span><br><span class="line">127.0.0.1	localhost</span><br><span class="line">::1	localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0	ip6-localnet</span><br><span class="line">ff00::0	ip6-mcastprefix</span><br><span class="line">ff02::1	ip6-allnodes</span><br><span class="line">ff02::2	ip6-allrouters</span><br><span class="line">172.17.0.4	tomcat1 612aeb07e2e7</span><br><span class="line">172.17.0.2	e7613df5b961</span><br></pre></td></tr></table></figure>
<ul>
<li>–link 就是在我们 hosts 中增加了一条虚拟域名</li>
</ul>
<h3 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h3><h4 id="查看所有的docker网络"><a href="#查看所有的docker网络" class="headerlink" title="查看所有的docker网络"></a>查看所有的docker网络</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">ea834618e218        bridge              bridge              local</span><br><span class="line">2da75ecdb782        host                host                local</span><br><span class="line">d7c3fa26b1bd        none                null                local</span><br></pre></td></tr></table></figure>

<h4 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h4><ul>
<li>bridge : 桥接模式(docker默认)</li>
<li>none : 不配置网络</li>
<li>host : 和宿主机共享网络</li>
<li>container : 容器网络连通(用的少, 局限很大)</li>
</ul>
<h4 id="创建自定义网络"><a href="#创建自定义网络" class="headerlink" title="创建自定义网络"></a>创建自定义网络</h4><ul>
<li>–subnet 子网</li>
<li>–gateway 网关</li>
<li>–driver 默认桥接模式 不写也可以</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker network create --driver bridge --subnet 192.168.0.0&#x2F;16 --gateway 192.168.0.1 mynet</span><br></pre></td></tr></table></figure>

<h4 id="查看自己创建的网络"><a href="#查看自己创建的网络" class="headerlink" title="查看自己创建的网络"></a>查看自己创建的网络</h4><ul>
<li>命令: docker network inspect mynet</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;mynet&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;6eb44c49b01928fd5c010c72c2738980814855e372a215eac422d35bdb1c70c4&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2020-09-22T05:58:08.319032125Z&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;192.168.0.0&#x2F;16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;192.168.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="使用自己创建的网络"><a href="#使用自己创建的网络" class="headerlink" title="使用自己创建的网络"></a>使用自己创建的网络</h4><ul>
<li>–net </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -P --net mynet --name tomcat-net-01 tomcat</span><br></pre></td></tr></table></figure>

<h5 id="再次测试"><a href="#再次测试" class="headerlink" title="再次测试"></a>再次测试</h5><ul>
<li>使用自己的网络创建两个容器并且相互ping 都是可以ping通的</li>
<li>比之前的 –link 要好很多</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it tomcat-net-01 ping tomcat-net-02</span><br><span class="line">PING tomcat-net-02 (192.168.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.073 ms</span><br><span class="line">64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.063 ms</span><br><span class="line">64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq&#x3D;3 ttl&#x3D;64 time&#x3D;0.063 ms</span><br><span class="line"></span><br><span class="line">#反向ping 也是可以的</span><br><span class="line">PING tomcat-net-01 (192.168.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.100 ms</span><br><span class="line">64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.078 ms</span><br></pre></td></tr></table></figure>

<h3 id="网络连通"><a href="#网络连通" class="headerlink" title="网络连通"></a>网络连通</h3><h4 id="容器在不同的网段内如何实现互通"><a href="#容器在不同的网段内如何实现互通" class="headerlink" title="容器在不同的网段内如何实现互通?"></a>容器在不同的网段内如何实现互通?</h4><blockquote>
<p>示意图</p>
</blockquote>
<p><img src="WX20200922-151404.png" alt=""></p>
<ul>
<li>我们会发现不同网段的容器不能ping通的.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it tomcat01 ping tomcat-net-01</span><br><span class="line">ping: tomcat-net-01: Name or service not known</span><br></pre></td></tr></table></figure>

<ul>
<li>所以需要使用 –network connect 命令</li>
</ul>
<h4 id="连通"><a href="#连通" class="headerlink" title="连通"></a>连通</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker network connect mynet tomcat01</span><br></pre></td></tr></table></figure>

<h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker network inspect mynet</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;mynet&quot;,</span><br><span class="line">        .....</span><br><span class="line">        .....</span><br><span class="line">        ...</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;0796e3b7250d5c49372183e28266de528dfe072bb884220aeff9f0ccab4521a7&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;tomcat-net-01&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;e53cde49134bf3fb72f9bcd801ac73e208705b8cae416b689a726511b1125d49&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;192.168.0.2&#x2F;16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;2a187f1b05a15d33c5cc382c2b84d0b93fa4748f3e2ce4daed0ca0bc7a4d0500&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;tomcat01&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;652193a8312425944682a4b48f2f1a1d35ec5e4cea6806fbe0d5be11380627e8&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:04&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;192.168.0.4&#x2F;16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">           .....</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ul>
<li>连通之后我们可以看到 tomcat01 容器直接放到了 mynet的网络下</li>
<li>这就是一个容器两个ip地址 </li>
<li>这样我们就可以ping通了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it tomcat01 ping tomcat-net-01</span><br><span class="line"></span><br><span class="line">PING tomcat-net-01 (192.168.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.082 ms</span><br><span class="line">64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.074 ms</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 概述</title>
    <url>/docker-study-summary/</url>
    <content><![CDATA[<h4 id="Docker为什么出现"><a href="#Docker为什么出现" class="headerlink" title="Docker为什么出现"></a>Docker为什么出现</h4><p>一款产品: 开发到上线,有两套环境自己本地的环境和生成环境, 这时候环境不一致可能会导致各种问题, 或者代码的版本更新导致的bug<br>另外一个原因: 环境的配置是十分麻烦的, 单机还算好说, 如果是集群的话每一台机器都需要部署环境 这是很费时费力的</p>
<p>例: 目前php项目上线都是先在服务器上部署好环境再把git仓库的代码拉去下来运行的, 这里就可能会产生环境不一致的问题, 所以有人就想能不能在项目打包的时候把环境也代码一起打包</p>
<p>传统: 开发写代码, 运维来部署<br>现在: 开发打包部署上线 ,一套流程做完</p>
<p>Docker 解决以上问题</p>
<h4 id="Docker-的核心思想"><a href="#Docker-的核心思想" class="headerlink" title="Docker 的核心思想"></a>Docker 的核心思想</h4><ul>
<li>Docker的思想来自于集装箱, 以php,nginx,mysql为例 其中的每个服务都是一个小的集装箱, 它们之间是相互隔离的</li>
<li>Docker想把所有的服务都打包装箱</li>
</ul>
<h4 id="Docker和虚拟机的区别"><a href="#Docker和虚拟机的区别" class="headerlink" title="Docker和虚拟机的区别"></a>Docker和虚拟机的区别</h4><ol>
<li>在容器技术出来之前, 我们使用的虚拟机技术</li>
<li>虚拟机是在 win, mac 系统中安装一个虚拟机软件, 通过软件我们可以虚拟出来一个或者多台电脑. 这样是很笨重的!</li>
<li>虚拟机也是虚拟化技术, Docker容器技术也是一种虚拟机技术</li>
</ol>
<blockquote>
<p>虚拟机技术</p>
</blockquote>
<p><img src="1.png" alt=""></p>
<h5 id="虚拟机的缺点"><a href="#虚拟机的缺点" class="headerlink" title="虚拟机的缺点"></a>虚拟机的缺点</h5><ul>
<li>占用资源多</li>
<li>冗余步骤多</li>
<li>启动慢</li>
</ul>
<blockquote>
<p>容器化技术</p>
</blockquote>
<p><label style="color:red">容器化技术它不是模拟的一个完整的操作系统</label></p>
<p><img src="2.png" alt=""></p>
<h4 id="Docker和虚拟机的不同"><a href="#Docker和虚拟机的不同" class="headerlink" title="Docker和虚拟机的不同"></a>Docker和虚拟机的不同</h4><ul>
<li>传统虚拟机, 虚拟出硬件, 运行一个完整的操作系统. 然后在这个系统上安装和运行软件</li>
<li>docker容器内直接运行宿主机的内核,容器是没有直接的内核的也没有虚拟硬件, 所以就轻便的很多</li>
<li>每个容器之间是相互隔离的, 每个容器内都有属于自己的文件系统, 互不影响 就算是有其中一个容器也就是服务挂了也不会影响到其他的容器正常运行</li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 学习大纲</title>
    <url>/docker-study/</url>
    <content><![CDATA[<h4 id="学习大纲"><a href="#学习大纲" class="headerlink" title="学习大纲"></a>学习大纲</h4><ul>
<li>Docker 概述</li>
<li>Docker 安装</li>
<li>Docker 命令<ul>
<li>镜像命令</li>
<li>容器命令</li>
<li>操作命令</li>
<li>…..</li>
</ul>
</li>
<li>Docker 镜像</li>
<li>容器数据卷</li>
<li>DockerFile</li>
<li>Docker网络原理</li>
<li>Docker Compose</li>
<li>Docker Swarm</li>
<li>CI\CD Jenkins</li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>MAC终端中如何在命令行中快速启动编辑器</title>
    <url>/editor/</url>
    <content><![CDATA[<h2 id="vscode-编辑器"><a href="#vscode-编辑器" class="headerlink" title="vscode 编辑器"></a>vscode 编辑器</h2><ol>
<li>打开控制面板（⇧⌘P)</li>
<li>输入 shell command  回车安装<br><img src="/images/twst.png" alt=""></li>
<li>在提示里看到 Shell Command: Install ‘code’ command in PATH， 就可以了</li>
</ol>
<h3 id="在命令行你需要打开的目录下运行"><a href="#在命令行你需要打开的目录下运行" class="headerlink" title="在命令行你需要打开的目录下运行"></a>在命令行你需要打开的目录下运行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code .</span><br></pre></td></tr></table></figure>

<h2 id="sublime-编辑器"><a href="#sublime-编辑器" class="headerlink" title="sublime 编辑器"></a>sublime 编辑器</h2><h3 id="1-找到sublime应用提供的命令行工具subl"><a href="#1-找到sublime应用提供的命令行工具subl" class="headerlink" title="1. 找到sublime应用提供的命令行工具subl"></a>1. 找到sublime应用提供的命令行工具subl</h3><p>下面是我的路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;Applications&#x2F;Sublime\ Text.app&#x2F;Contents&#x2F;SharedSupport&#x2F;bin&#x2F;subl</span><br></pre></td></tr></table></figure>

<h3 id="2-找到自己用的bash-给里面写入-我使用的是-zshrc"><a href="#2-找到自己用的bash-给里面写入-我使用的是-zshrc" class="headerlink" title="2. 找到自己用的bash 给里面写入(我使用的是 zshrc)"></a>2. 找到自己用的bash 给里面写入(我使用的是 zshrc)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alias sub&#x3D;&quot;&#x2F;Applications&#x2F;Sublime\ Text.app&#x2F;Contents&#x2F;SharedSupport&#x2F;bin&#x2F;subl&quot;</span><br></pre></td></tr></table></figure>

<h3 id="3-命令行运行"><a href="#3-命令行运行" class="headerlink" title="3. 命令行运行"></a>3. 命令行运行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~&#x2F;.zshrc</span><br></pre></td></tr></table></figure>

<p>完成以上步骤你就可以在命令行中运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sub .    打开当前目录</span><br><span class="line">sub xxx  打开指定文件夹 或 文件</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>sublime</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂方法模式</title>
    <url>/factory-method/</url>
    <content><![CDATA[<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><ul>
<li>创建型模式</li>
<li>工厂方法为了解决简单工厂扩展性的问题</li>
<li>简单工厂要扩展的时候, 需要修改工厂内容, 这就违背了设计模式对外扩展开放, 对内修改关闭原则 所以就有了工厂方法模式.</li>
</ul>
<h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><ul>
<li>还是简单工厂模式的那个栗子, 我们发现简单工厂模式违背了开闭原则,那么怎么解决个问题呢请看下面</li>
</ul>
<h3 id="工厂方法模式流程图"><a href="#工厂方法模式流程图" class="headerlink" title="工厂方法模式流程图"></a>工厂方法模式流程图</h3><p><img src="QQ20200928-155642.jpg" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>为了满足闭合原则, 同时不去改动之前的代码(也就是简单工厂中的静态方法)</li>
<li>只要是实现了接口类我们就可以随意的去扩展代码,从而避免修改之前的代码</li>
<li>如果这样的话代码量会很多,个人觉得在工作中还是要根据实际情况来决定</li>
</ul>
<h3 id="完整示例代码"><a href="#完整示例代码" class="headerlink" title="完整示例代码:"></a>完整示例代码:</h3><p><a href="https://github.com/whcoding/design-patterns-study/tree/master/src/Factory/Method">Github</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>简单工厂模式</title>
    <url>/factory/</url>
    <content><![CDATA[<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><ul>
<li>创建型模式</li>
<li>作用: 实现了创建者和调用者分离</li>
</ul>
<h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>假设:用户需要买车,每一个车就是一个类, 每一个类都需要new一次, 周一买特斯拉 周二买奥迪 周三买宝马 这样每次都会更改大量的代码.</p>
<h4 id="常规流程图"><a href="#常规流程图" class="headerlink" title="常规流程图:"></a>常规流程图:</h4><p><img src="QQ20200928-094926.jpg" alt=""></p>
<h4 id="常规的代码"><a href="#常规的代码" class="headerlink" title="常规的代码:"></a>常规的代码:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; $car &#x3D; new Tesla();</span><br><span class="line">&#x2F;&#x2F; $car &#x3D; new Audi();</span><br><span class="line">$car &#x3D; new Benz();</span><br><span class="line"></span><br><span class="line">echo $car-&gt;name();</span><br></pre></td></tr></table></figure>

<h4 id="简单工厂模式流程图"><a href="#简单工厂模式流程图" class="headerlink" title="简单工厂模式流程图:"></a>简单工厂模式流程图:</h4><p><img src="QQ20200928-160008.jpg" alt=""></p>
<h4 id="简单工厂模式代码"><a href="#简单工厂模式代码" class="headerlink" title="简单工厂模式代码:"></a>简单工厂模式代码:</h4><p>工厂文件代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Factory</span><br><span class="line">&#123;</span><br><span class="line">    public static function GetLogic($carName)</span><br><span class="line">    &#123;</span><br><span class="line">        $instance &#x3D; null;</span><br><span class="line">        if ($carName &#x3D;&#x3D; &#39;奥迪&#39;) &#123;</span><br><span class="line">           $instance &#x3D; new Audi();</span><br><span class="line">        &#125; elseif ($carName &#x3D;&#x3D; &#39;宝马&#39;) &#123;</span><br><span class="line">            $instance &#x3D; new Benz();</span><br><span class="line">        &#125; elseif ($carName &#x3D;&#x3D; &#39;特斯拉&#39;) &#123;</span><br><span class="line">            $instance &#x3D; new Tesla();</span><br><span class="line">        &#125;</span><br><span class="line">        return $instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户文件代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$myCar &#x3D; Factory::GetLogic(&#39;宝马&#39;);</span><br><span class="line">echo $myCar-&gt;name();</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h3><blockquote>
<p>优点</p>
</blockquote>
<ul>
<li>一个调用者想创建一个对象, 只要知道其名称就可以了.</li>
<li>扩展性高,如果想增加一个产品,只要扩展一个工厂类就可以.</li>
<li>屏蔽了类的具体实现, 调用者只关心产品的接口.</li>
</ul>
<blockquote>
<p>缺点</p>
</blockquote>
<ul>
<li>每次增加一个产品时, 都需要修改一个具体类和对象实现工厂, 使得系统中类的个数成倍增加, 在一定程度上增加了系统的复杂度, 同时也增加了系统具体类的依赖</li>
<li>同时也违背了设计模式的开闭原则, 因为每次增加一辆车或产品的类都需要去修改工厂方法, 正因为这个原则所以就有了 方法工厂模式</li>
</ul>
<h3 id="完整示例代码"><a href="#完整示例代码" class="headerlink" title="完整示例代码:"></a>完整示例代码:</h3><p><a href="https://github.com/whcoding/design-patterns-study/tree/master/src/Factory/Simple">Github</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Github clone 加速</title>
    <url>/github-clone/</url>
    <content><![CDATA[<h4 id="分辨需要设置的代理"><a href="#分辨需要设置的代理" class="headerlink" title="分辨需要设置的代理"></a>分辨需要设置的代理</h4><p>HTTP 形式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;xxx&#x2F;git.git</span><br></pre></td></tr></table></figure>

<p>SSH 形式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:xxx&#x2F;git.git</span><br></pre></td></tr></table></figure>


<h5 id="HTTP-代理"><a href="#HTTP-代理" class="headerlink" title="HTTP 代理"></a>HTTP 代理</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy http:&#x2F;&#x2F;127.0.0.1:8080</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global https.proxy http:&#x2F;&#x2F;127.0.0.1:8080</span><br></pre></td></tr></table></figure>

<h5 id="socks5-代理（如-Shadowsocks）"><a href="#socks5-代理（如-Shadowsocks）" class="headerlink" title="socks5 代理（如 Shadowsocks）"></a>socks5 代理（如 Shadowsocks）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy socks5:&#x2F;&#x2F;127.0.0.1:1080</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global https.proxy socks5:&#x2F;&#x2F;127.0.0.1:1080</span><br></pre></td></tr></table></figure>

<h4 id="取消设置"><a href="#取消设置" class="headerlink" title="取消设置"></a>取消设置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure>

<h5 id="只对-github-进行代理-对国内的仓库不影响-可以这样设置"><a href="#只对-github-进行代理-对国内的仓库不影响-可以这样设置" class="headerlink" title="只对 github 进行代理, 对国内的仓库不影响, 可以这样设置"></a>只对 github 进行代理, 对国内的仓库不影响, 可以这样设置</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global http.https:&#x2F;&#x2F;github.com.proxy https:&#x2F;&#x2F;127.0.0.1:1080</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global https.https:&#x2F;&#x2F;github.com.proxy https:&#x2F;&#x2F;127.0.0.1:1080</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>VitrualBox Vagrant Homestead 的关系</title>
    <url>/homestead/</url>
    <content><![CDATA[<h2 id="VitrualBox"><a href="#VitrualBox" class="headerlink" title="VitrualBox"></a>VitrualBox</h2><p>VitrualBox 是一款非常强大的免费虚拟机软件，使用者可以在 VitrualBox 上安装并运行 Linux、Windows、Mac OS X 等操作系统，类似的软件还有 VMware</p>
<h2 id="Vagrant"><a href="#Vagrant" class="headerlink" title="Vagrant"></a>Vagrant</h2><p>Vagrant 是一个用于创建和部署虚拟化开发环境的工具，其依赖于 VirtualBox 虚拟机，致力于帮助开发者快速构建一个环境统一的虚拟系统。</p>
<p>Vagrant 可以将一整套虚拟环境封装在一个box 内，这样只要所有人都使用这个 box，大家的开发环境就实现统一了！而 Homestead 就是这样一个 Laravel 官方预装的适合 Laravel 开发的 Vagrant box 。</p>
<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>其实可以这样理解，你有了虚拟机（VirtualBox）,有了集成环境（homestead环境也就是vagrant box）,那么你总需要把集成环境放到虚拟机上是吧。那么谁来做这个事情呢？必须要有人来做才行啊，不然的话，虚拟机是不会自己装环境的。vagrant 就是做这个事情的</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>VirtualBox 是虚拟机软件<br>vagrant 是管理虚拟机的工具，主要作用是提供一个可配置、可移植和复用的软件环境<br>Homestead 里面包含了 Nginx Web 服务器、PHP 7、MySQL、Postgres、Redis、Memcached、Node，以及所有你在使用 Laravel 开发时需要用到的各种软件（Homestead Box 虚拟机盒子），它一套可配置的 Laravel 开发环境（Homestead 管理脚本）</p>
]]></content>
      <categories>
        <category>Homestead</category>
      </categories>
      <tags>
        <tag>Homestead</tag>
        <tag>VitrualBox</tag>
        <tag>Vagrant</tag>
      </tags>
  </entry>
  <entry>
    <title>给你的网站免费配置 https</title>
    <url>/https/</url>
    <content><![CDATA[<h6 id="letsencrypt-为1-8亿个网站提供TLS证书的非盈利性证书颁发机构"><a href="#letsencrypt-为1-8亿个网站提供TLS证书的非盈利性证书颁发机构" class="headerlink" title="letsencrypt  为1.8亿个网站提供TLS证书的非盈利性证书颁发机构"></a><a href="https://letsencrypt.org/zh-cn/">letsencrypt</a>  为1.8亿个网站提供TLS证书的非盈利性证书颁发机构</h6><h5 id="安装-letsencrypt"><a href="#安装-letsencrypt" class="headerlink" title="安装 letsencrypt"></a>安装 letsencrypt</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt install letsencrypt</span><br></pre></td></tr></table></figure>

<h5 id="生成-ssl-所需证书文件"><a href="#生成-ssl-所需证书文件" class="headerlink" title="生成 ssl 所需证书文件"></a>生成 ssl 所需证书文件</h5><p>注意: 生成的时候要先停止 nginx </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">letsencrypt certonly --standalone --email your@mail.com -d text1.com -d text2.com</span><br></pre></td></tr></table></figure>

<h5 id="成功生成如下"><a href="#成功生成如下" class="headerlink" title="成功生成如下:"></a>成功生成如下:</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IMPORTANT NOTES:</span><br><span class="line">- Congratulations! Your certificate and chain have been saved at</span><br><span class="line">&#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;xxx&#x2F;fullchain.pem. Your cert</span><br><span class="line">will expire on 2020-05-19. To obtain a new version of the</span><br><span class="line">certificate in the future, simply run Let&#39;s Encrypt again.</span><br><span class="line">- If you like Let&#39;s Encrypt, please consider supporting our work by:</span><br><span class="line">Donating to ISRG &#x2F; Let&#39;s Encrypt:   https:&#x2F;&#x2F;letsencrypt.org&#x2F;donate</span><br><span class="line">Donating to EFF:                    https:&#x2F;&#x2F;eff.org&#x2F;donate-le</span><br></pre></td></tr></table></figure>
<h5 id="证书有效期只有-90-天-免费续期的命令如下"><a href="#证书有效期只有-90-天-免费续期的命令如下" class="headerlink" title="证书有效期只有 90 天, 免费续期的命令如下"></a>证书有效期只有 90 天, 免费续期的命令如下</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">letsencrypt certonly --renew-by-default --email your@mail.com -d text1.com -d text2.com</span><br></pre></td></tr></table></figure>

<h5 id="配置-crontab-定时任务-自动续期"><a href="#配置-crontab-定时任务-自动续期" class="headerlink" title="配置 crontab 定时任务, 自动续期"></a>配置 crontab 定时任务, 自动续期</h5><h6 id="编写自动续期脚本-updateHttps-sh"><a href="#编写自动续期脚本-updateHttps-sh" class="headerlink" title="编写自动续期脚本, updateHttps.sh"></a>编写自动续期脚本, updateHttps.sh</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service nginx stop</span><br><span class="line"></span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;letsencrypt certonly --renew-by-default --email your@mail.com -d text1.com -d text2.com</span><br><span class="line"></span><br><span class="line">sudo service nginx start</span><br></pre></td></tr></table></figure>
<h6 id="crontab-e"><a href="#crontab-e" class="headerlink" title="crontab -e"></a>crontab -e</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* * 1 * * &#x2F;realpath&#x2F;updateHttps.sh</span><br></pre></td></tr></table></figure>

<h5 id="修改-nginx-conf-添加-https"><a href="#修改-nginx-conf-添加-https" class="headerlink" title="修改 nginx.conf, 添加 https"></a>修改 nginx.conf, 添加 https</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">	# 强制跳转https</span><br><span class="line">	if ($scheme &#x3D; http) &#123;</span><br><span class="line">	   return 301 https:&#x2F;&#x2F;$server_name$request_uri;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	listen 443 ssl;</span><br><span class="line">	ssl_certificate   &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;text1.comfullchain.pem;</span><br><span class="line">	ssl_certificate_key  &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;text1.comprivkey.pem;</span><br><span class="line">	ssl_session_timeout 5m;</span><br><span class="line">	ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">	ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">	ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>https</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一下 Windows 下搭建 Homestead 的两大坑</title>
    <url>/intall_homestead/</url>
    <content><![CDATA[<p><a href="https://www.vagrantup.com/">vagrant</a>版本 2.2.6<br><a href="https://www.virtualbox.org/">virtualbox</a> 版本 6.1</p>
<h2 id="1-第一大坑"><a href="#1-第一大坑" class="headerlink" title="1. 第一大坑"></a>1. 第一大坑</h2><p><img src="https://cdn.learnku.com/uploads/images/202001/21/25180/dpwrxTRuvG.png!large" alt="记录一下 Windows 下搭建 Homestead 的两大坑"></p>
<p>上面的报错意思就是,  vagrant 不支持 安装版本的 virtualbox</p>
<p>然后我就想 不应该啊 我都去官网 安装的最新版本 为什么会出这样的错误呢?<br>最终经过 百度 找到了 Vagrant 在 GitHub 上的仓库 查看了 issue 果然 已经有大神解决了</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p><a href="https://github.com/oracle/vagrant-boxes/issues/178?utm_source=hacpai.com">issues</a><br>链接里讲的很明白, 只需要手动修复一下 跟着操作就可以了.</p>
<h3 id="第二个解决办法"><a href="#第二个解决办法" class="headerlink" title="第二个解决办法"></a>第二个解决办法</h3><p>如果你懒的手动去改这些文件, 那么你只需要去下载旧版本的  <a href="https://www.virtualbox.org/wiki/Download_Old_Builds_6_0">virtualbox</a> 重新安装就可以了.</p>
<h2 id="2-第二大坑"><a href="#2-第二大坑" class="headerlink" title="2. 第二大坑"></a>2. 第二大坑</h2><p><img src="https://cdn.learnku.com/uploads/images/202001/21/25180/F5NC4eAFoM.png!large" alt="记录一下 Windows 下搭建 Homestead 的两大坑"><br>这里的报错意思就是,  电脑没有开启 vt虚拟化</p>
<p>打开任务管理器, 然后到 性能 选项页, 在右下角虚拟化中我们就可以看到了</p>
<p><img src="https://cdn.learnku.com/uploads/images/202001/21/25180/WQ1JezGZxR.png!large" alt="记录一下 Windows 下搭建 Homestead 的两大坑"><br>知道了问题, 去百度自己的 主板 怎么开启虚拟化就可以了, 我的是 <a href="https://zhidao.baidu.com/question/1962404983578552180.html">华硕主板</a></p>
<h3 id="最后还是想说一句-还是-Mac-下开发省心啊"><a href="#最后还是想说一句-还是-Mac-下开发省心啊" class="headerlink" title="最后还是想说一句 还是 Mac 下开发省心啊!"></a>最后还是想说一句 还是 Mac 下开发省心啊!</h3>]]></content>
      <categories>
        <category>Homestead</category>
      </categories>
      <tags>
        <tag>Homestead</tag>
      </tags>
  </entry>
  <entry>
    <title>基金理财</title>
    <url>/money/</url>
    <content><![CDATA[<h3 id="为什么要理财"><a href="#为什么要理财" class="headerlink" title="为什么要理财"></a>为什么要理财</h3><ol>
<li><p>平衡一生收支的差距<br>一个人一辈子可以赚取收入的年岁有限. 即便能力超凡之人, 也可能面临时运不济、收入骤减状况. 如被迫下岗待业或营运不佳导致收入减少或中断；或因天之不测风云、人之旦夕祸福冲击造成收入减少或中断, 支出却增加.<br>所以一定要理财的第一个重大理由就是：通过理财妥善规划安排个人家庭财务状况, 以能”平衡一生收支的差距” 保障将来老有所养, 自己晚年的生活独立, 富足. </p>
</li>
<li><p>对抗通货膨胀<br>从近3至5年的货币走势来看, 钱是逐渐贬值的, 官方公布的年CPI(消费者物价指数)在2～3%, 换个说法即通账率是2～3%, 即如果钱放在手上不动, 在第二年要贬值2个百分点, 按价值等量关系, 今年100元的东西, 明年要102或103元才能买到等价值的东西, 何况实际情况远非官方公布的数据这么低.<br>大家都感觉到钱一年不如一年值钱, 尤其在房价表现得尤为明显. 要使自己手中的钱不像夏天的冰棍那样易化, 最起码要跑赢通货膨胀.</p>
</li>
<li><p>财务自由<br>终极目标, 尽可能的达到或者要有睡后税收入, 也就是不靠出卖劳动力、时间等去赚钱 所谓的财务自由就是非工资收入大于总支出 <strong><em>财务自由=被动收入&gt;花销</em></strong><br>被动收入: 你什么都不需要做这个钱也会自己到账<br>举例: 假如每个月有3000元的<strong><em>被动收入</em></strong> 而你的月支付是2500元, 那你已经达到了财富自由的状态. </p>
</li>
</ol>
<h3 id="本金问题"><a href="#本金问题" class="headerlink" title="本金问题"></a>本金问题</h3><ul>
<li>买理财或者基金不要去赌</li>
<li>假如说有 100W本金 年收益率有10% 那么就有10W的被动收入 10% 是个保险做法 </li>
<li>假如有 10W本金 想要有10W的收益 那么就得有100%的年收益率 这个就是有极大的风险的</li>
</ul>
<h3 id="为什么说普通人适合基金投资"><a href="#为什么说普通人适合基金投资" class="headerlink" title="为什么说普通人适合基金投资"></a>为什么说普通人适合基金投资</h3><blockquote>
<p>普通人的投资渠道</p>
</blockquote>
<ol>
<li>银行存款或余额宝等</li>
<li>证券投资:股票</li>
<li>房地产投资</li>
<li>支付宝理财</li>
<li>基金</li>
</ol>
<blockquote>
<p>银行存款</p>
</blockquote>
<ul>
<li>收益率太低这是主要原因, 目前银行,余额宝等年利率在 1.5% 左右 </li>
<li>10W * 1.5% = 1500 收益太低, 跑不赢通货膨胀</li>
</ul>
<blockquote>
<p>股票</p>
</blockquote>
<ul>
<li>上手门槛高, 选股难 等</li>
<li>波动率大, 一个涨停或者跌停就是10% </li>
<li>技术性太高, 一般人承受不了. </li>
</ul>
<blockquote>
<p>房地产投资</p>
</blockquote>
<ul>
<li>门槛高</li>
<li>收益兑现难</li>
<li>而且现在已经不是炒房的最好时机了</li>
</ul>
<blockquote>
<p>支付宝理财</p>
</blockquote>
<ul>
<li>比较稳定, 亏的几率很小但是同时收益也小, 可能比银行高一点</li>
</ul>
<blockquote>
<p>基金</p>
</blockquote>
<ul>
<li>以上的问题, 基金都可以很好的解决</li>
<li>想要收益高就配置指数型基金, 股票型基金, 混合型基金</li>
<li>想要稳点 就配置货币基金, 纯债基金</li>
</ul>
<h3 id="认识基金"><a href="#认识基金" class="headerlink" title="认识基金"></a>认识基金</h3><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><ol>
<li>债券: <strong><em>付息还钱</em></strong> 也就是有人向你借钱, 还钱的时候需要还利息和本金</li>
<li>股票: 不还钱, 但共同分享公司的成果 假如买了10W元的股票 100股 这个公司赚钱了股票升值了, 需要抛售股票来赚取中间的差价</li>
<li>A股: 中国境内发行的股票, 看国运 也是看今年国家发展的怎么样</li>
<li>指数: 通常一家公司发现一只股票, 很多家公司就会有很多只股票, 这些股票成群结队,就组成了不同的指数</li>
<li>大盘: 上证指数, 在上海交易所上市发行的所有股票的组合</li>
<li>小盘: 中证500指数 选取了500家中小公司的股票组合</li>
<li>基金: 基金就是基金公司拿我们的钱, 去投资帮我们买股票,债券等 帮助我们打理 比较出名的基金公司: 天弘, 富国, 华夏等 <strong><em>千万不要找p2p的公司</em></strong></li>
</ol>
<h5 id="货币基金"><a href="#货币基金" class="headerlink" title="货币基金"></a>货币基金</h5><ol>
<li>货币基金是聚集社会闲散资金, 由基金管理人运作, 基金托管人保管资金的一种开放式基金, 专门投向风险小的货币市场工具, 区别于其他类型的开放式基金, 具有高安全性、高流动性、稳定收益性, 具有“准储蓄”的特征</li>
<li>开放式的 可以随时买和随时卖, 就像支付宝的余额宝一样</li>
<li>比较稳健, 可以购买一些债券基金避免风险</li>
</ol>
<h5 id="短债基金"><a href="#短债基金" class="headerlink" title="短债基金"></a>短债基金</h5><p>1. </p>
]]></content>
      <categories>
        <category>理财</category>
      </categories>
      <tags>
        <tag>理财</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql 慢查询</title>
    <url>/mysql-slow/</url>
    <content><![CDATA[<h4 id="查询是否开启-mysql-慢查询"><a href="#查询是否开启-mysql-慢查询" class="headerlink" title="查询是否开启 mysql 慢查询"></a>查询是否开启 mysql 慢查询</h4><ol>
<li>首先进入到 mysql 命令行模式 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u 用户名 -p</span><br></pre></td></tr></table></figure></li>
<li>查看是否开启慢查询功能<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;slow_query%&#39;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------------------+-----------------------------------+</span><br><span class="line">| Variable_name       | Value                             |</span><br><span class="line">+---------------------+-----------------------------------+</span><br><span class="line">| slow_query_log      | OFF                                |</span><br><span class="line">| slow_query_log_file | &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;homestead-slow.log |</span><br><span class="line">+---------------------+-----------------------------------+</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>slow_query_log = off  表示没有开启慢查询</li>
<li>slow_query_log_file    表示慢查询日志存放的目录</li>
</ul>
<h4 id="开启慢查询和相关设置"><a href="#开启慢查询和相关设置" class="headerlink" title="开启慢查询和相关设置"></a>开启慢查询和相关设置</h4><ol>
<li>开启慢查询(及时性重启mysql后失效)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global slow_query_log&#x3D;ON;</span><br></pre></td></tr></table></figure></li>
<li>设置慢查询日志存放的位置<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global slow_query_log_file&#x3D;&#39;&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;slow.log&#39;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="设置慢查询时间-超过此值的sql将会记录下来"><a href="#设置慢查询时间-超过此值的sql将会记录下来" class="headerlink" title="设置慢查询时间(超过此值的sql将会记录下来)"></a>设置慢查询时间(超过此值的sql将会记录下来)</h4><ol>
<li>查询当前的设置的时间(mysql默认10秒)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;long_query%&#39;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-----------------+-----------+</span><br><span class="line">| Variable_name   | Value     |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| long_query_time | 10.000000 |</span><br><span class="line">+-----------------+-----------+</span><br></pre></td></tr></table></figure></li>
<li>设置慢查询时间<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set long_query_time&#x3D;0.5;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>通常来说一条sql执行时间不应该超过500毫秒, 这个时间已经很慢了</li>
<li>sql执行50毫秒左右最佳</li>
<li>这里要提一下程序执行的时间不止是sql 还需要php代码执行等因素,所以一般来说 get请求100毫秒左右, post请求 200毫秒以内 超过这个时间就需要具体优化了.</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>更改 nginx php-fpm 运行用户</title>
    <url>/nginx-php-fpm/</url>
    <content><![CDATA[<h4 id="为什么要更改运行用户"><a href="#为什么要更改运行用户" class="headerlink" title="为什么要更改运行用户"></a>为什么要更改运行用户</h4><ul>
<li>nginx 和 fpm 默认运行用户的 www-data</li>
<li>再部署项目的时候 一般来说都是用自己创建的用户去 <code>git clone</code> 代码 所以 <code>clone</code> 下来的代码文件 都属于这个用户, 所以在运行项目的时候就会有很多权限的问题, 所以要改变 nginx 和 fpm 的默认运行用户</li>
</ul>
<h4 id="更改-nginx-默认用户"><a href="#更改-nginx-默认用户" class="headerlink" title="更改 nginx 默认用户"></a>更改 nginx 默认用户</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user 更改这里;</span><br><span class="line">worker_processes auto;</span><br><span class="line">pid &#x2F;run&#x2F;nginx.pid;</span><br><span class="line">include &#x2F;etc&#x2F;nginx&#x2F;modules-enabled&#x2F;*.conf;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">        worker_connections 768;</span><br><span class="line">        # multi_accept on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="更改-php-fpm-默认用户"><a href="#更改-php-fpm-默认用户" class="headerlink" title="更改 php-fpm 默认用户"></a>更改 php-fpm 默认用户</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;php&#x2F;7.3&#x2F;fpm&#x2F;pool.d&#x2F;www.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">..... </span><br><span class="line">user &#x3D; 更改这里</span><br><span class="line">group &#x3D; 更改这里</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line">listen.owner &#x3D; 更改这里</span><br><span class="line">listen.group &#x3D; 更改这里</span><br></pre></td></tr></table></figure>

<p>最后要记得 重启 nginx 和 php-fpm </p>
]]></content>
      <categories>
        <category>环境</category>
      </categories>
      <tags>
        <tag>环境</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx 提示错误 &quot;No input file specified&quot;</title>
    <url>/nginx_error/</url>
    <content><![CDATA[<h3 id="nginx-错误日志"><a href="#nginx-错误日志" class="headerlink" title="nginx 错误日志:"></a>nginx 错误日志:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PHP Warning:  Unknown: failed to open stream: Operation not permitted in Unknown on line 0&quot; while reading response header from upstream, client: 127.0.0.1, server: www.classmate.com, request: &quot;GET &#x2F; HTTP&#x2F;1.1&quot;, upstream: &quot;fastcgi:&#x2F;&#x2F;127.0.0.1:9000&quot;, host: &quot;www.classmate.com&quot;</span><br><span class="line">2019&#x2F;05&#x2F;15 14:14:23 [error] 14488#16204: *4 FastCGI sent in stderr: &quot;PHP Warning:  Unknown: open_basedir restriction in effect. File(E:\code\xxx\index.php) is not within the allowed path(s): (&#x2F;mnt&#x2F;e&#x2F;code&#x2F;xxx:&#x2F;tmp&#x2F;:&#x2F;proc&#x2F;) in Unknown on line 0</span><br></pre></td></tr></table></figure>
<h3 id="问题的产生"><a href="#问题的产生" class="headerlink" title="问题的产生"></a>问题的产生</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">问题的产生最近刚好在研究win10子系统 安装了个lnmp一键安装 vhost 指向了 这个项目 产生了.user.ini</span><br><span class="line">.user.ini是lnmp文件，里面放的是你网站的文件夹路径地址。目的是防止跨目录访问和文件跨目录读取</span><br><span class="line">然后切换到win10下phpstudy环境出现上述问题.</span><br><span class="line">解决方案 在项目下找到.user.ini文件 删除</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统学习</title>
    <url>/operating-system/</url>
    <content><![CDATA[<h2 id="操作系统简介"><a href="#操作系统简介" class="headerlink" title="操作系统简介"></a>操作系统简介</h2><h3 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h3><ol>
<li>操作系统是 一种复杂的<strong>系统软件</strong>, 是不同 <strong>程序代码</strong> 丶<strong>数据结构</strong>丶 <strong>数据初始化文件</strong>的集合,可执行. (选择题 填空题 简答题)</li>
</ol>
<ol start="2">
<li>操作系统（Operating System, OS）是一种复杂的<strong>系统软件</strong>, 是不<strong>同程序代码、数据结构、数据初始化文件的集合</strong>，可执行. (选择题 填空题 简答题)</li>
</ol>
<ol start="3">
<li>操作系统<strong>与硬件部分相互作用</strong>，并且为运行在计算机上的<strong>应用程序提供执行环境.</strong> (选择题 填空题</li>
</ol>
<ol start="4">
<li>操作系统屏蔽了对接硬件操作的细节, 提供了计算机用户与计算机硬件之间的<strong>接口</strong>, 并且通过这接口, 使 *<em>应用程序 *</em>的开发变得简单高效. (选择题)</li>
</ol>
<ol start="5">
<li><p>操作系统必须完成的目标: (承上启下)</p>
<ul>
<li><p>用户与硬件之间的接口</p>
</li>
<li><p>操作系统<strong>与硬件部分相互作用</strong></p>
</li>
<li><p>为运行在计算机上的<strong>应用程序提供执行环境.</strong></p>
</li>
</ul>
</li>
</ol>
<ol start="6">
<li><p>资源的管理者</p>
<ul>
<li>现在计算机系统的一个重要特点就是支持 <strong>多任务</strong></li>
<li>处理机就是CPU</li>
<li>操作系统负者管理计算机的<strong>资源</strong></li>
</ul>
</li>
</ol>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><ol>
<li>网络操作系统 管理的资源还包括 <strong>网卡</strong> 丶 <strong>带宽</strong></li>
<li>网络操作系统有 Windows下的 net </li>
</ol>
<h3 id="操作系统的发展"><a href="#操作系统的发展" class="headerlink" title="操作系统的发展"></a>操作系统的发展</h3><ul>
<li>操作系统每更新一次都会弥补之前的缺点</li>
</ul>
<h5 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h5><ol>
<li>单道批处理系统 <strong>内存中只有一道作业</strong> CPU和内存资源被用户作业<strong>独占</strong> (选择题, 填空题)</li>
<li>特点: <strong>自动型</strong>丶 <strong>顺序型</strong>丶 <strong>单道型</strong>  (选择题, 填空题)</li>
<li><strong>单道批处理系统的优点: 减少了等待人工操作的时间</strong>  (选择题, 简答题)</li>
<li><strong>单道批处理系统的缺点: CPU资源不能得到充分利用</strong>  (选择题, 简答题)</li>
</ol>
<h5 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h5><ol>
<li><p>由操作系统的<strong>作业调度程序</strong>按一定策略从<strong>后备作业队列</strong>中选择<strong>若干</strong>个作业调入内存，使它们共享CPU和系统中的各种资源 (选择题, 填空题)</p>
</li>
<li><p>特点: <strong>多道性丶 无序性丶调度性丶复杂性</strong> (选择题, 填空题)</p>
</li>
<li><p>优点: <strong>能够提高CPU,内存和IO设备的利用率和吞吐率</strong> (选择题, 填空题)</p>
</li>
<li><p>缺点: *<em>系统平均周转时间长,缺乏交互能力 *</em>(选择题, 填空题) </p>
</li>
</ol>
<h5 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h5><ol>
<li><p>允许<strong>多个用户</strong>通过终端机<strong>同时使用计算机</strong>，每个用户通过终端与主机交互时都能得到<strong>快速响应</strong> (选择题)</p>
</li>
<li><p>特点: <strong>多路性、独立性、及时性、交互性</strong> ** (选择题, 填空题) </p>
</li>
<li><p>优点:  向用户提供了<strong>人机交互的方便行</strong>, 使多个用户可以通过不同的终端*<em>共享主机 *</em>(选择题) </p>
</li>
</ol>
<h5 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h5><ol>
<li>实时系统必须<strong>及时响应</strong>外部事件的请求，在<strong>规定时间内</strong>完成对该事件的处理。主要用于<strong>实时控制</strong>和<strong>实时信息处理领域</strong>  (选择题, 填空题)</li>
<li>特点：<strong>多路性、独立性、及时性、交互性、可靠性</strong>  (选择题, 填空题)</li>
</ol>
<h5 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h5><ul>
<li>CPU只能访问内存</li>
</ul>
<h3 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h3><ul>
<li>现在操作系统都支持 <strong>多任务</strong> 具有<strong>并发丶共享丶虚拟和异步性</strong>的特征 (选择题, 填空题, 简答题)</li>
</ul>
<h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><ul>
<li>并发是两个或者多个在同一个<strong>时间间隔内</strong>发生 (选择题, 填空题, 简答题)</li>
</ul>
<h4 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h4><ul>
<li><p>系统中的<strong>资源</strong>可供内存中<strong>多个</strong>并发执行的进程共同使用  (选择题, 填空题, 简答题)</p>
</li>
<li><p>其中共享有分为 <strong>互斥共享</strong>和<strong>同时共享</strong></p>
</li>
<li><p>互斥共享: 同一时刻一种资源只能被一个进程访问</p>
</li>
<li><p>同时共享: 从宏观上看,资源可以被多个进程同时访问, 并发和共享关系是相互依赖的.</p>
</li>
</ul>
<h4 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h4><ul>
<li>常用于内存虚拟化, 让用户感觉到内存大于实际内存</li>
</ul>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><ul>
<li>进程以<strong>不可预知的速度</strong>向前推荐</li>
</ul>
<h4 id="扩展-2"><a href="#扩展-2" class="headerlink" title="扩展"></a>扩展</h4><ul>
<li>并行是指多个在同一时间同时发生</li>
<li>并发是两个或者多个在同一个时间间隔内发生</li>
</ul>
<h3 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h3><h3 id="操作系统的系统结构"><a href="#操作系统的系统结构" class="headerlink" title="操作系统的系统结构"></a>操作系统的系统结构</h3><h3 id="指令的执行"><a href="#指令的执行" class="headerlink" title="指令的执行"></a>指令的执行</h3>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP卸载pecl 安装的扩展</title>
    <url>/pecl/</url>
    <content><![CDATA[<h2 id="PHP卸载pecl-安装的扩展"><a href="#PHP卸载pecl-安装的扩展" class="headerlink" title="PHP卸载pecl 安装的扩展"></a>PHP卸载pecl 安装的扩展</h2><p>php.ini 中删除 extension=swoole.so</p>
<p>卸载,切换到PHP安装目录下的bin</p>
<p>./pecl uninstall swoole(已swoole为例)</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP扩展</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/single/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 开发必装软件</title>
    <url>/software/</url>
    <content><![CDATA[<h2 id="办公工具"><a href="#办公工具" class="headerlink" title="办公工具"></a>办公工具</h2><ul>
<li><a href="https://www.dingtalk.com">钉钉</a></li>
<li><a href="https://weixin.qq.com">微信</a></li>
<li><a href="https://im.qq.com">QQ</a></li>
<li><a href="https://www.office.com">Office</a> / <a href="https://www.wps.cn">WPS</a></li>
<li><a href="https://pinyin.sogou.com/mac">搜狗拼音</a></li>
<li><a href="https://www.google.cn/intl/zh-CN/chrome">Chrome</a></li>
<li><a href="https://zh.xnipapp.com">Xnip</a></li>
<li><a href="https://www.alfredapp.com">Alfred</a></li>
<li><a href="https://molunerfinn.com/PicGo">PicGo</a></li>
<li><a href="https://pqrs.org/osx/karabiner">Karabiner</a></li>
<li><a href="https://totalfinder.binaryage.com">TotalFinder</a></li>
<li><a href="https://dozermac.com">Dozer</a></li>
<li><a href="https://iina.io">iina</a></li>
<li><a href="https://pasteapp.me/">Paste</a></li>
</ul>
<h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><ul>
<li><a href="https://www.jetbrains.com/phpstorm">PHPStorm</a></li>
<li><a href="http://www.sublimetext.com">Sublime Text</a></li>
<li><a href="https://www.navicat.com.cn">Navicat</a></li>
<li><a href="https://www.iterm2.com">iTerm2</a> / Termius<br>– <a href="https://ohmyz.sh">OhMyZsh</a><br>– <a href="https://brew.sh">homebrew</a></li>
<li><a href="https://www.getpostman.com">Postman</a></li>
<li><a href="https://github.com/oldj/SwitchHosts">SwitchHosts</a></li>
<li><a href="https://cornerstone.assembla.com">Cornerstone</a></li>
<li><a href="https://www.sourcetreeapp.com">Sourcetree</a></li>
<li><a href="https://filezilla-project.org">FileZilla</a></li>
<li><a href="https://github.com/uglide/RedisDesktopManager">RedisDesktopManager</a> / <a href="https://github.com/luin/medis">Medis</a></li>
<li><a href="https://www.charlesproxy.com">Charles</a></li>
<li><a href="https://www.virtualbox.org/">virtualbox</a><br>– Homestead</li>
</ul>
<h2 id="娱乐工具"><a href="#娱乐工具" class="headerlink" title="娱乐工具"></a>娱乐工具</h2><ul>
<li><a href="https://music.163.com">网易云音乐</a></li>
</ul>
<h3 id="小提示"><a href="#小提示" class="headerlink" title="小提示"></a>小提示</h3><p>点击软件名称请按住 command 键</p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>环境</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>Sublime Text 编辑器插件</title>
    <url>/sublime/</url>
    <content><![CDATA[<h4 id="Sublime插件网站"><a href="#Sublime插件网站" class="headerlink" title="Sublime插件网站:"></a>Sublime插件网站:</h4><p><a href="https://packagecontrol.io">https://packagecontrol.io</a></p>
<h4 id="插件推荐"><a href="#插件推荐" class="headerlink" title="插件推荐"></a>插件推荐</h4><p>Localized​Menu  汉化插件<br>Docphpmanualer PHP手册<br>align Tab 代码对齐插件<br>AutoFileName  快捷输入文件名插件<br>BracketHighlighter: 代码匹配插件，可匹配[], (), {}等<br>Ctags 函数跳转<br>Doc​Blockr 注释插件<br>CodeFormatter: 代码格式化插件<br>ConvertToUTF8: 编辑并保存目前编码不被 Sublime Text<br>DocBlockr: 代码注释插件，标准的注释，包括函数名、参数、返回值等，并以多行显示，省去手动编写。<br>Emmet: HTML/CSS代码快速编写插件，对于前端来说，可是必备插件。<br>IMESupport: 实现中文输入法鼠标跟随插件。<br>AllAutocomplete 经典自动补全，只适用于当前文件。在当前窗口的所有打开文件中搜索可以大大简化开发过程<br>Project Manager  项目切换插件<br>Plain​Tasks   (phpstrom 的 todo)<br>EditorConfig帮助开发人员在不同编辑器之间保持一致的编码风格<br>KeymapManager: 快捷键管理插件，通过Ctrl+alt+k或者通过顶部菜单“查看 -&gt; 快捷键管理”打开面板。<br>PackageControl: 插件管理插件，提供添加、删除、禁用、查找插件等功能。<br>SideBarEnhancements: 侧边栏右键增强插件，可以自定义打开方式快捷键，非常实用。<br>Side​Bar​Tools 侧边栏右键增强插件<br>SublimeCodeIntel: 代码自动提示插件，支持绝大多数前端开发语言。<br>SublimeLinter: 代码语法检测插件<br>sublimeLinter-php 配合上面的使用PHP语法错误提示<br>SyncedSidebarBg: 侧边栏与主题颜色同步更新插件，自动同步侧边栏底色为编辑窗口底色。<br>Theme-Nil: 完美的编码主题，用过的都说很好<br>jquery   : 写前端jq</p>
<p>Q：如何安装插件？<br>A：按快捷键Ctrl+Shift+P，输入 install 并回车，选择相应插件安装即可。或者依次点击“首选项 - 插件控制 - Install Package”进行插件安装。</p>
]]></content>
      <categories>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>Sublime Text</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu 系统安装 lnmp环境</title>
    <url>/ubuntu-lnmp/</url>
    <content><![CDATA[<h5 id="更新-apt-get"><a href="#更新-apt-get" class="headerlink" title="更新 apt-get"></a>更新 apt-get</h5><pre><code>命令: sudo apt update</code></pre><h5 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h5><pre><code>命令: sudo apt install nginx </code></pre><p>安装完成之后可以在浏览器看到 nginx 默认欢迎页</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;server_domain_or_ip</span><br></pre></td></tr></table></figure>
<p><img src="/images/nginx_default.png" alt=""><br>如果看到上面的页面,则说明您已经成功安装了 nginx</p>
<h5 id="安装-mysql"><a href="#安装-mysql" class="headerlink" title="安装 mysql"></a>安装 mysql</h5><pre><code>命令: sudo apt install mysql-server</code></pre><p>运行完命令 Mysql数据库 就已经安装了, 但没配置完成.</p>
<p>为了确保安全, Mysql附带了一个脚步, 运行该脚本会询问我们是否修改一些不安全的默认值, 通过以下命令来启动脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mysql_secure_installation</span><br></pre></td></tr></table></figure>
<p>同意 Y ‘是’, 否则继续进行任何操作(不启用).</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VALIDATE PASSWORD PLUGIN can be used to test passwords</span><br><span class="line">and improve security. It checks the strength of password</span><br><span class="line">and allows the users to set only those passwords which are</span><br><span class="line">secure enough. Would you like to setup VALIDATE PASSWORD plugin?</span><br><span class="line"></span><br><span class="line">Press y|Y for Yes, any other key for No:</span><br></pre></td></tr></table></figure>

<p>如果启用了验证,则脚本还将要求您选择密码验证级别,如果输入2(最高级别),则设置复杂的密码包括大小写字母特殊字符等, 否则都会收到错误消息.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">There are three levels of password validation policy:</span><br><span class="line"></span><br><span class="line">LOW    Length &gt;&#x3D; 8</span><br><span class="line">MEDIUM Length &gt;&#x3D; 8, numeric, mixed case, and special characters</span><br><span class="line">STRONG Length &gt;&#x3D; 8, numeric, mixed case, special characters and dictionary                  file</span><br><span class="line"></span><br><span class="line">Please enter 0 &#x3D; LOW, 1 &#x3D; MEDIUM and 2 &#x3D; STRONG: 1</span><br></pre></td></tr></table></figure>
<p>接下来, 将要求您提交并确认root密码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Please set the password for root here.</span><br><span class="line"></span><br><span class="line">New password:</span><br><span class="line"></span><br><span class="line">Re-enter new password:</span><br></pre></td></tr></table></figure>
<p>其余的问题,您应该在每个提示下按下Y并ENTER击键. 这将删除一些匿名用户和测试数据库,禁用远程root登录,并加载这些新规则. 以便MySQL立即遵守我们所做的更改.</p>
<h6 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h6><p>请注意, 在运行MySQL 5.7(及更高版本) Ubuntu系统中, 默认情况下, MySQL为 root 用户设置使用auth_socket插件而非密码进行身份验证. 在许多情况下,这可以提高安全性和可用性,但是当您需要允许外部程序(例如phpMyAdmin)访问时也可能变得不方便.</p>
<h6 id="更换Mysql-root用户密码验证"><a href="#更换Mysql-root用户密码验证" class="headerlink" title="更换Mysql root用户密码验证"></a>更换Mysql root用户密码验证</h6><p>如果您希望以root用户身份连接到MySQL时使用密码, 则需要将其身份验证方法从切换auth_socket为mysql_native_password. 为此,请从终端打开MySQL提示符.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mysql</span><br></pre></td></tr></table></figure>

<p>接下来, 使用以下命令检查每个MySQL用户帐户使用的身份验证方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT user,authentication_string,plugin,host FROM mysql.user;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+------------------+-------------------------------------------+-----------------------+-----------+</span><br><span class="line">| user             | authentication_string                     | plugin                | host      |</span><br><span class="line">+------------------+-------------------------------------------+-----------------------+-----------+</span><br><span class="line">| root             |                                           | auth_socket           | localhost |</span><br><span class="line">| mysql.session    | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE | mysql_native_password | localhost |</span><br><span class="line">| mysql.sys        | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE | mysql_native_password | localhost |</span><br><span class="line">| debian-sys-maint | *CC744277A401A7D25BE1CA89AFF17BF607F876FF | mysql_native_password | localhost |</span><br><span class="line">+------------------+-------------------------------------------+-----------------------+-----------+</span><br><span class="line">4 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>在此示例中, 可以看到root用户使用auth_socket插件进行身份验证. 要将root帐户配置使用密码进行身份验证, 请运行以下ALTER USER命令 .确保更改password为您选择的强密码</p>
<p>其中 ‘password’ 为您要设置的 root 用户的密码, 如果密码验证级别输入的是 2(最高级别), 请输入复杂的密码 否则会有错误提示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt;  ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;password&#39;;</span><br></pre></td></tr></table></figure>
<p>然后，运行FLUSH PRIVILEGES告诉服务器重新加载授权表并使新的更改生效：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt;  FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p>再次检查每个用户使用的身份验证方法, 以确认root不再使用auth_socket插件进行身份验证：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT user,authentication_string,plugin,host FROM mysql.user;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Output</span><br><span class="line">+------------------+-------------------------------------------+-----------------------+-----------+</span><br><span class="line">| user             | authentication_string                     | plugin                | host      |</span><br><span class="line">+------------------+-------------------------------------------+-----------------------+-----------+</span><br><span class="line">| root             | *3636DACC8616140347782ADD08F92C1571D6D78F | mysql_native_password | localhost |</span><br><span class="line">| mysql.session    | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE | mysql_native_password | localhost |</span><br><span class="line">| mysql.sys        | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE | mysql_native_password | localhost |</span><br><span class="line">| debian-sys-maint | *CC744277A401A7D25BE1CA89AFF17BF607F876FF | mysql_native_password | localhost |</span><br><span class="line">+------------------+-------------------------------------------+-----------------------+-----------+</span><br><span class="line">4 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>您可以在此示例输出中看到, MySQL root 用户现在使用密码进行了身份验证. 一旦在自己的服务器上确认了这一点，就可以退出MySQL Shell：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; exit;</span><br></pre></td></tr></table></figure>
<h6 id="注意2"><a href="#注意2" class="headerlink" title="注意2:"></a>注意2:</h6><p>将root的 MySQL用户配置为使用密码进行身份验证后, 将无法再sudo mysql使用以前使用的命令访问MySQL. 相反必须运行以下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>
<p>至此, mysql数据库系统已经完成了, 可以继续安装PHP</p>
<h5 id="安装PHP"><a href="#安装PHP" class="headerlink" title="安装PHP"></a>安装PHP</h5><p>使用下面的命令将 <code>ondrej/php</code> 添加到Ubuntu的存储库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install software-properties-common</span><br><span class="line">sudo add-apt-repository ppa:ondrej&#x2F;php</span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<h6 id="安装-PHP7-4-以及-php-mysql"><a href="#安装-PHP7-4-以及-php-mysql" class="headerlink" title="安装 PHP7.4 以及 php-mysql"></a>安装 PHP7.4 以及 php-mysql</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install php7.4-fpm php7.4-mysql</span><br></pre></td></tr></table></figure>

<h6 id="安装-PHP插件"><a href="#安装-PHP插件" class="headerlink" title="安装 PHP插件"></a>安装 PHP插件</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install php7.4-&lt;插件名称&gt;</span><br></pre></td></tr></table></figure>
<p>php安装完成以后就需要配置nginx 虚拟主机</p>
<h5 id="配置-nginx-虚拟主机"><a href="#配置-nginx-虚拟主机" class="headerlink" title="配置 nginx 虚拟主机"></a>配置 nginx 虚拟主机</h5><p>在<code>/etc/nginx/sites-available/</code> 目录中打开一个配置文件, 在此示例中新的服务器块配置文件名为example.com</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vi &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;example.com</span><br></pre></td></tr></table></figure>
<p>将以下内容添加到<code>example.com</code>配置文件中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        root &#x2F;var&#x2F;www&#x2F;html;</span><br><span class="line">        index index.php index.html index.htm index.nginx-debian.html;</span><br><span class="line">        server_name example.com;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">                try_files $uri $uri&#x2F; &#x3D;404;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location ~ \.php$ &#123;</span><br><span class="line">                include snippets&#x2F;fastcgi-php.conf;</span><br><span class="line">                fastcgi_pass unix:&#x2F;var&#x2F;run&#x2F;php&#x2F;php7.4-fpm.sock;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location ~ &#x2F;\.ht &#123;</span><br><span class="line">                deny all;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a>软连接</h6><p>添加此内容后,保存并关闭文件. 通过软连接的形式来启用此配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ln -s &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;example.com &#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;</span><br></pre></td></tr></table></figure>
<p>取消默认配置的软连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo unlink &#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;default</span><br></pre></td></tr></table></figure>
<p>测试新配置文件的语法错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo nginx -t</span><br></pre></td></tr></table></figure>
<p>没有问题的话,重启nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service nginx restat</span><br></pre></td></tr></table></figure>
<p>这样就完成了LEMP的安装和配置,和相互通信</p>
<h6 id="测试是否正常运行"><a href="#测试是否正常运行" class="headerlink" title="测试是否正常运行"></a>测试是否正常运行</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vi &#x2F;var&#x2F;www&#x2F;html&#x2F;info.php</span><br></pre></td></tr></table></figure>
<p>加入以下内容:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">phpinfo();</span><br></pre></td></tr></table></figure>
<p>完成后,保存并关闭文件.</p>
<p>现在, 可以在浏览器中访问此页面, 访问服务器的域名或公共IP地址 后面跟/info.php：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;your_server_domain_or_IP&#x2F;info.php</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>lnmp</category>
      </categories>
      <tags>
        <tag>环境</tag>
      </tags>
  </entry>
</search>
